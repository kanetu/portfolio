{"pageProps":{"frontmatter":"{\"title\":\"Array Không Chỉ Là Array \",\"date\":\"2018-09-09T05:45:40.000Z\",\"status\":\"publish\",\"thumbnail\":\"images/post-thumbnail/array-khong-chi-la-array.png\",\"description\":\"Hầu hết các ngôn ngữ đều trang bị kiểu aray để xử lý, lưu trữ nhiều phần tử cùng lúc, JS cũng không ngoại lệ NHƯNG array trong JS không chỉ đơn giản là array.\",\"tags\":[\"javascript\"]}","content":"\nHầu hết các ngôn ngữ đều trang bị kiểu aray để xử lý, lưu trữ nhiều phần tử cùng lúc, JS cũng không ngoại lệ NHƯNG array trong JS không chỉ đơn giản là array.\nChúng ta có thể dùng array làm:\n\n1. Array, cái này đương nhiên.\n2. Stack.\n3. Queue.\n4. Dictionary.\n5. Sortable List.\n6. String Builder.\n7. Combo.\n\n## 1️. Stack\n\nBỏ qua cái thứ 1, chúng ta có thể dùng array như 1 stack, đặc tính của stack là LIFO (đi trễ về sớm). Có 2 method để là chuyện này là push và pop\n\n```javascript\nconst array = [1, 2, 3];\narray.push(4); // => [1, 2, 3, 4]\narray.pop(); // => [1, 2, 3]\n```\n\n## 2. Queue\n\nSử dụng array như 1 queue cũng có 2 method là unshift (enqueue), shift (dequeue) để đảm bảo đặc tính FIFO (đi sớm về sớm)\n\n```javascript\nconst array = [1, 2, 3];\narray.shift(); // => [2, 3\narray.unshift(1); // => [1, 2, 3]\n```\n\n## 3. Dictionary\n\nDùng array như môt Dictionary có hơi miễn cưỡng nhưng ok, fine, nó vẫn hoạt động bình thường\n\n```javascript\nconst array = [1, 2, 3];\narray['$key1'] = 1; => [1, 2, 3]\narray.$key2 = 2; => [1, 2, 3]\ndelete array.$key; => [1, 2, 3]\n```\n\nNhư các bạn đã thấy, việc thao tác trên key có 2 điểm cần lưu ý, key phải thêm ký tự phân biệt nào đó để tránh trùng tên với những prop/method của array, ở đây mình dùng dấu $. Thứ hai là việc thêm hay xóa key không làm thay đổi số lượng phần tử trong array. Muốn duyệt key thì dùng\n\n```javascript\nfor(let key in array) // => 1, 2, 3, $key1 (không có $key2 vì đã bị delete)\n```\n\n## 4. Sortable List\n\nDùng array như sortable list khá đơn giản, bản thân method sort của array là mutable nên mỗi lần thêm item mới vào thì chúng ta sort lại\n\n```javascript\nconst array = [5, 6, 7];\narray.push(1); // => [5, 6, 7, 1]\narray.sort(); // => [1, 5, 6, 7]\n```\n\n## 5. String Builder\n\nArray còn được sử dụng như String Builder, đa số ngôn ngữ lập trình, việc nối chuỗi mất khá nhiều bộ nhớ và chậm, vi mỗi lần nối chuỗi thì hệ thống phải cấp phát vùng nhớ mới rộng hơn, ứng với độ dài chuỗi củ và mới cộng lại, sau đó sao chép cả 2 vào đó. Nên xử lý chuỗi nhiều có thể làm chậm he thống, vì vậy String Builder ra đời, giúp tối ưu việc chỉnh sửa chuỗi.\n\n```javascript\nconst stringBuilder = [];\nfor(let i [0; i < 10000; i++) {\n  stringBuilder.push('Hello World');\n}\nconst result = stringBuilder.join('');\n```\n\n## 6. Combo\n\nCách này là một cách tà đạo của array, dùng kết hợp array + dictionary. Ví dụ bạn có một hàm tìm kiếm theo điều kiện sau đó trả về danh sách kết quả tìm được và thứ tự của các phần tử đó trong danh sách ban đầu\n\n```javascript\nconst userTable = [{ name: \"A\" }, { name: \"B\" }, { name: \"C\" }];\nfunction findUsers(predicate) {\n  const indexes = [];\n  const users = userTable.filter((user, index) => {\n    if (predicate(user)) {\n      indexes.push(index);\n      return true;\n    }\n    return false;\n  });\n  return { users, indexes };\n}\nconst result = findUsers((user) => user.name === \"A\" || user.name === \"C\");\nconsole.log(result.users); // => [ { name: 'A' }, { name: 'C' } ]\nconsole.log(result.indexes); // => [0, 2]\n\n// cách làm truyền thống như trên có thể thay thế bằng\nfunction findUsers(predicate) {\n  const indexes = [];\n  const users = userTable.filter((user, index) => {\n    if (predicate(user)) {\n      indexes.push(index);\n      return true;\n    }\n    return false;\n  });\n  users.indexes = indexes;\n  return users;\n}\nconst result = findUsers((user) => user.name === \"A\" || user.name === \"C\");\nconsole.log(result); // => [ { name: 'A' }, { name: 'C' } ]\nconsole.log(result.indexes); // => [0, 2]\n```\n\n☑️ Tổng kết lại thì JS trang bị một kiểu array quá bá đạo, nó có thể đảm nhiệm nhiều chức năng của những kiểu dữ liệu khác nhau. Vẫn câu nói cũ: Tuy đơn giản nhưng không kém phần phức tạp :D\n"},"__N_SSG":true}