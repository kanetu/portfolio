{"pageProps":{"frontmatter":"{\"title\":\"Scope và Hoisting\",\"date\":\"2018-10-11T08:45:40.000Z\",\"status\":\"publish\",\"thumbnail\":\"images/post-thumbnail/scope-va-hoisting.png\",\"description\":\"Khi làm việc với javascript có bao giờ các bạn đã để ý là chúng ta hoàn toàn có thể sử dụng một biến trước khi chúng được khai báo không?. Thật ra mà nói thì không hề có chuyện sử dụng một biến trước khi nó được khai báo đâu, chỉ là với javascript thì ngôn ngữ này có cơ chế Hoisting vậy Hoisting là gì?\",\"tags\":[\"javascript\"]}","content":"\nKhi làm việc với javascript có bao giờ các bạn đã để ý là chúng ta hoàn toàn có thể sử dụng một biến trước khi chúng được khai báo không?. Thật ra mà nói thì không hề có chuyện sử dụng một biến trước khi nó được khai báo đâu, chỉ là với javascript thì ngôn ngữ này có cơ chế Hoisting vậy Hoisting là gì?\n\n## 1. Hoisting là gì?\n\nHoisting được hiểu là khi chúng ta khai báo biến (chỉ khi dùng `var`) thì javascript sẽ chuyển lên trên cùng của hàm.\n\nChúng ta xét ví dụ:\n\n```javascript\nmyFunc();\n\nfunction myFunc() {\n  console.log(x);\n  var x = 3;\n}\n// kết quả là undefined\n```\n\nTheo cơ chế Hoisting thì javascript sẽ hiểu như sau:\n\n```javascript\nmyFunc();\n\nfunction myFunc() {\n  var x; // x lúc này chưa được gán giá trị thì tức nhiên là undefined\n  console.log(x);\n  x = 3;\n}\n// kết quả là undefined\n```\n\nVậy nó có đúng như tôi nói không ? chúng ta sẽ sử dụng 1 hàm kiểm tra xem biến đó đã tồn tại hay chưa để hiểu rõ liệu có gì sai sai ở đây không.\n\nHãy ấn F12 chọn Console để kiểm chứng đoạn code bên dưới\n\n```javascript\nmyFunc();\n\nfunction myFunc() {\n  console.log(y);\n}\n```\n\nNếu bản thân trong hàm `myFunc()` không được khai báo thì khi chạy nó sẽ xuất hiện 1 lỗi như sau:\n\n```javascript\nVM113:4 Uncaught ReferenceError: y is not defined\n    at myFunc (< anonymous >:4:14)\n    at < anonymous >:1:1\n```\n\nNếu nó không báo lỗi thì sao? thì có lẽ bạn đã khai báo biến đó ở bên ngoài hàm rồi. Javascript sẽ tìm theo thứ tự inner -> outer, ngộ nhỡ bạn khai báo biến `a` trong hàm `myFunc()` và khai báo biến `a` ở ngoài hàm thì theo cơ chế `Scope in javascript` thì nếu bên trong hàm không có thì nó sẽ lấy bên ngoài hàm. Bạn có thể kiểm chứng - Try it yourself.\n\nChúng ta thấy tiếp một định nghĩa `Scope` vậy scope là giống gì?\n\n## 2️. Scope là gì\n\nScope trong Javascript được hiểu là phạm vi biến hay phạm vi truy cập của biến, phạm vi này được xác định bằng khoảng trống giữa 2 dấu braces `{}` , hmm đến đây thì Scope được chia thành 2 loại là `Global scope` và `Local scope`, đương nhiên chúng ta học nó không chỉ cho biết mà là để trong lúc làm việc ta xác định được cái nào là Global cái nào là Local để biết đường mà fix bugs, bảo trì.\n\nHmm.. ngồi tra 1 tí nhiều định nghĩa lắm chứ không ít đâu ngoài `local scope`,`global scope` mà cón có: function scope, lexical scope, scope chain, closure ..\n\n### 2.1 Global scope\n\nChữ Global ở đây được hiểu là toàn cục, 1 biến toàn cục là biến được khai báo không nằm trong bất kì 1 hàm nào, ví dụ:\n\n```javascript\n// những biến khai báo ngoài đây đều là biến Global\nvar global_var = 3;\n\nfunction myFunc(x) {\n  // trong đây là 1 scope khác\n}\n```\n\nĐấy đơn giản dễ hiểu không cầu kì :).\n\n```\n    Global scope là bạn tốt nhất và cũng là cơn ác mộng tồi tệ nhất!!! Nếu không nắm rõ mình đang nằm trong scope nào, chắc chắn ta sẽ gặp vấn đề với global scope (thường là xung đột namespace). Người ta cứ nói rằng việc dùng Global scope là rất dở, nhưng không phải trong mọi trường hợp\n```\n\n### 2.2 Local Scope\n\nLocal được hiểu là cục bộ, những biến khai báo trong 1 hàm được gọi là `Local scope`\n\n```javascript\n// những biến khai báo ngoài đây đều là biến Global\n\nfunction myFunc(x) {\n  // trong đây là 1 scope khác\n  // biến nào khai báo trong đây được hiểu là Local\n}\n```\n\nHiểu đơn giản là vậy trước đã tiếp theo là phần nâng cao 1 tí đây\n\n### 2.3 Function scope\n\nNhư tôi nói ở phần định nghĩa thì Scope được xác định bằng khoảng trống giữa 2 dấu braces `{}` nhưng nó chỉ đúng khi chúng ta khởi tạo 1 hàm, còn lại những `{}` của vòng lặp hay câu lệnh rẽ nhánh đều không tạo ra `scope` như:\n\n1. `if`\n2. `switch`\n3. `for..`\n4. `while..`\n5. `...`\n\n```javascript\n// Scope A\nvar myFunction = function () {\n  // Scope B\n  var myOtherFunction = function () {\n    // Scope C\n  };\n};\n```\n\n### 2.3 Lexical scope\n\nKhi nhìn thấy một function nằm trong một function khác, function bên trong có quyền truy cập tới scope của function bên ngoài, đó gọi là `Lexical Scope` hay `Closure` - còn được gọi là `Static Scope`. Ví dụ:\n\n```javascript\n// Scope A\nvar myFunction = function () {\n  // Scope B\n  var name = \"Kane\"; // định nghĩa trong Scope B\n  var myOtherFunction = function () {\n    // Scope C: \"name\" vẫn có thể được truy cập đến từ đây!!\n  };\n};\n```\n\nLàm việc với Lexical scope cũng khá là dễ dàng, bật cứ biến/object/ function được định nghĩa trong scope cha, đều có thể được truy cập bởi các scope con nhỏ hơn\n\n```javascript\nvar name = \"Kane\";\n//Scope A\nvar scope1 = function () {\n  // name có thể sử dụng ở đây\n  //Scope B\n  var scope2 = function () {\n    // name có thể sử dụng ở đây\n    // Scope C\n    var scope3 = function () {\n      // name có thể sử dụng ở đây\n      // Scope D\n    };\n  };\n};\n```\n\nChú ý, Lexical scope không hoạt động theo chiều ngược lại, tức là biến/object/function định nghĩa trong scope con thì ko thể truy cập bởi scope cha.\n\nDấu `->` có nghĩa là có thể sử dụng, dựa vào ví dụ trên ta suy ra được thứ tự khả dụng\n\nScope D -> Scope C -> Scope B -> Scope A\n\nVà ta không thể truy xuất biến của các scope theo chiều ngược lại như:\n\nScope A -> Scope B -> Scope C -> Scope D\n\n### 2.4 Scope Chain\n\nHiểu đơn giản là nếu chúng ta sử dụng 1 biến `varA` trong hàm `myFunc()` mà hàm này không có biến `varA` thì nó sẽ tìm kiếm những biến nào có tên `varA` ở những scope liên tiếp bên ngoài nó.\n\nĐiều này khả dụng với Lexical scope, xét ví dụ:\n\n```javascript\nvar name = \"Kane\";\n//Scope A\nvar scope1 = function () {\n  // name có thể sử dụng ở đây\n  //Scope B\n  var scope2 = function () {\n    // name có thể sử dụng ở đây\n    // Scope C\n    var scope3 = function () {\n      // name có thể sử dụng ở đây\n      // Scope D\n      console.log(name);\n    };\n  };\n};\n```\n\nnếu `name` không có trong scope D thì nó sẽ tìm từng scope cha của nó từ trong ra ngoài scope nào có biến cùng tên `name` thì nó lấy\n\nScope D (name? yes:'no') -> Scope C (name? yes:'no') -> Scope B (name? yes:'no')-> Scope A (name? 'yes':no)\n\n### 2.6 Closures\n\nClosure có mối quan hệ chặt chẽ với Lexical Scope. Ví dụ tiêu biểu về cách thức hoạt động của closure đó là khi 1 function trả về tham chiếu tới 1 function.\n\n```javascript\nvar sayHello = function (name) {\n  var text = \"Hello, \" + name;\n  return function () {\n    console.log(text);\n  };\n};\n```\n\nKhái niệm `closure` làm cho scope của ta không thể tiếp cận được public scope. Chỉ gọi function sẽ không thực hiện gì bởi nó trả về kết quả là tham chiếu tới function.\n\n```javascript\nsayHello(\"Kane\"); // nó trả về tham chiếu của function và không thực hiện gì cả\n```\n\nĐể method hoạt động ta cần gán nó vào biến rồi mới thực thi:\n\n```js\nvar helloMethod = sayHello(\"Kane\");\nhelloMethod(); // Hello Kane\n```\n\nKhông nhất thiết phải trả về function mới được gọi là closure. Đơn giản chỉ cần truy cập tới biến nằm ngoài Lexical scope cũng là closure.\n\n## 3. Tài liệu kham khảo\n\n[Everything you wanted to know about JavaScript scope](https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/#what-is-scope)\n"},"__N_SSG":true}